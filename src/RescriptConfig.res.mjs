// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "sury/src/S.res.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var isDev = S.meta(S.transform(S.option(S.literal("dev")), (function (param) {
            return {
                    p: (function (string) {
                        if (string === "dev") {
                          return true;
                        } else {
                          return false;
                        }
                      }),
                    s: (function (bool) {
                        if (bool) {
                          return "dev";
                        }
                        
                      })
                  };
          })), {
      description: "True if the source is a dev dependency, false if it is not."
    });

function subdirs(sourcesRef) {
  return S.union([
              S.transform(S.option(S.bool), (function (param) {
                      return {
                              p: (function (bool) {
                                  if (bool !== undefined && bool) {
                                    return "TraverseAll";
                                  } else {
                                    return "NoSubdirs";
                                  }
                                }),
                              s: (function (val) {
                                  if (typeof val !== "object" && val === "TraverseAll") {
                                    return true;
                                  }
                                  
                                })
                            };
                    })),
              S.transform(sourcesRef, (function (s) {
                      return {
                              p: (function (val) {
                                  return {
                                          TAG: "SubdirList",
                                          _0: val
                                        };
                                }),
                              s: (function (val) {
                                  if (typeof val !== "object") {
                                    return s.fail("Should not happen!", undefined);
                                  } else {
                                    return val._0;
                                  }
                                })
                            };
                    }))
            ]);
}

function sourceItem(sourcesRef) {
  return S.object(function (s) {
              return {
                      dir: s.f("dir", S.meta(S.string, {
                                description: "Name of the directory"
                              })),
                      isDev: s.f("type", isDev),
                      subdirs: s.f("subdirs", subdirs(sourcesRef))
                    };
            });
}

function sourceConfig(sourcesRef) {
  return S.union([
              sourceItem(sourcesRef),
              S.transform(S.string, (function (s) {
                      return {
                              p: (function (val) {
                                  return {
                                          dir: val,
                                          isDev: false,
                                          subdirs: "NoSubdirs"
                                        };
                                }),
                              s: (function (val) {
                                  if (!val.isDev) {
                                    var tmp = val.subdirs;
                                    if (typeof tmp !== "object" && tmp !== "TraverseAll") {
                                      return val.dir;
                                    }
                                    
                                  }
                                  return s.fail("Should not happen!", undefined);
                                })
                            };
                    }))
            ]);
}

function wrapInArray(schema) {
  return S.transform(schema, (function (s) {
                return {
                        p: (function (val) {
                            return [val];
                          }),
                        s: (function (val) {
                            if (val.length !== 1) {
                              return s.fail("Can't convert back to array when array has more than one element.", undefined);
                            } else {
                              return val[0];
                            }
                          })
                      };
              }));
}

var sources = S.recursive(function (sourcesRef) {
      return S.meta(S.union([
                      wrapInArray(sourceConfig(sourcesRef)),
                      S.array(sourceConfig(sourcesRef))
                    ]), {
                  description: "An array of source items."
                });
    });

function optionalArray(schema) {
  return S.$$Option.getOrWith(S.option(S.array(schema)), (function () {
                return [];
              }));
}

var configSpec = S.object(function (s) {
      return {
              name: s.f("name", S.string),
              sources: s.f("sources", sources),
              dependencies: s.f("bs-dependencies", S.meta(optionalArray(S.string), {
                        description: "Rescript dependencies of the library, like in package.json. Currently searches in node_modules."
                      })),
              devDependencies: s.f("bs-dev-dependencies", S.meta(optionalArray(S.string), {
                        description: "Rescript dev dependencies of the library, like in package.json. Currently searches in node_modules."
                      })),
              pinnedDependencies: s.f("pinned-dependencies", S.meta(optionalArray(S.string), {
                        description: "Dependencies that are pinned (see docs)."
                      }))
            };
    });

function configFromJsonString(jsonString) {
  try {
    return {
            TAG: "Ok",
            _0: S.parseJsonStringOrThrow(jsonString, configSpec)
          };
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S.$$Error) {
      return {
              TAG: "Error",
              _0: error._1.message
            };
    }
    throw error;
  }
}

function configFromJson(json) {
  try {
    return {
            TAG: "Ok",
            _0: S.parseJsonOrThrow(json, configSpec)
          };
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S.$$Error) {
      return {
              TAG: "Error",
              _0: error._1.message
            };
    }
    throw error;
  }
}

export {
  isDev ,
  subdirs ,
  sourceItem ,
  sourceConfig ,
  wrapInArray ,
  sources ,
  optionalArray ,
  configSpec ,
  configFromJsonString ,
  configFromJson ,
}
/* isDev Not a pure module */
